import { BrowserWindow, dialog, ipcMain } from 'electron'
import { Client } from 'ssh2'
import type { SFTPWrapper } from 'ssh2'
import { spawn } from 'child_process'
import { Duplex } from 'stream'
import type { CommandGenerationContext } from '@shared/WebviewMessage'
import { createLogger } from '@logging'

const logger = createLogger('ssh')

function safeAppPath(): string {
  try {
    const { app } = require('electron') as { app?: { getAppPath?: () => string } }
    if (app?.getAppPath) return app.getAppPath()
  } catch {}
  return process.cwd()
}

const appPath = safeAppPath()
const packagePath = path.join(appPath, 'package.json')

// Try to read package.json from appPath first, fallback to __dirname if not exists
let packageInfo
try {
  if (fs.existsSync(packagePath)) {
    packageInfo = JSON.parse(fs.readFileSync(packagePath, 'utf8'))
  } else {
    const fallbackPath = path.join(__dirname, '../../package.json')
    packageInfo = JSON.parse(fs.readFileSync(fallbackPath, 'utf8'))
  }
} catch (error) {
  logger.warn('Failed to read package.json', { event: 'ssh.config', error: error instanceof Error ? error.message : String(error) })
  // Provide a default packageInfo object if both paths fail
  packageInfo = { name: 'chaterm', version: 'unknown' }
}
import { createProxySocket } from './proxy'
import { buildErrorResponse } from './jumpserver/errorUtils'

import {
  jumpserverConnections,
  handleJumpServerConnection,
  jumpserverShellStreams,
  jumpserverExecStreams,
  jumpserverMarkedCommands,
  jumpserverConnectionStatus,
  jumpserverLastCommand,
  createJumpServerExecStream
} from './jumpserverHandle'
import path from 'path'
import fs from 'fs'
import { SSHAgentManager } from './ssh-agent/ChatermSSHAgent'
import { getAlgorithmsByAssetType } from './algorithms'
import { connectBastionByType, shellBastionSession, resizeBastionSession, writeBastionSession, disconnectBastionSession } from './bastionPlugin'

// Hybrid buffer strategy configuration
const FLUSH_CONFIG = {
  INSTANT_SIZE: 16, // < 16 bytes: send immediately (user input)
  INSTANT_DELAY: 0, // 0ms
  SMALL_SIZE: 256, // < 256 bytes: short delay
  SMALL_DELAY: 10, // 10ms
  LARGE_SIZE: 1024, // < 1KB: medium delay
  LARGE_DELAY: 30, // 30ms
  BULK_DELAY: 50 // >= 1KB: long delay (bulk output)
}

// Helper function to determine delay based on buffer size
const getDelayByBufferSize = (size: number): number => {
  if (size < FLUSH_CONFIG.INSTANT_SIZE) {
    return FLUSH_CONFIG.INSTANT_DELAY
  } else if (size < FLUSH_CONFIG.SMALL_SIZE) {
    return FLUSH_CONFIG.SMALL_DELAY
  } else if (size < FLUSH_CONFIG.LARGE_SIZE) {
    return FLUSH_CONFIG.LARGE_DELAY
  } else {
    return FLUSH_CONFIG.BULK_DELAY
  }
}

// Store SSH connections
export const sshConnections = new Map()

// SSH connection reuse pool: stores connections that have passed MFA authentication
interface ReusableConnection {
  conn: any // SSH Client
  sessions: Set<string> // Set of session IDs using this connection
  host: string
  port: number
  username: string
  hasMfaAuth: boolean // Flag indicating whether MFA authentication has been completed
}
const sshConnectionPool = new Map<string, ReusableConnection>()

// Generate unique key for connection pool
const getConnectionPoolKey = (host: string, port: number, username: string): string => {
  return `${host}:${port}:${username}`
}

interface SftpConnectionInfo {
  isSuccess: boolean
  sftp?: any
  error?: string
}
export const sftpConnections = new Map<string, SftpConnectionInfo>()

// Execute command result
export interface ExecResult {
  stdout: string
  stderr: string
  exitCode?: number
  exitSignal?: string
}

// Store shell session streams
const shellStreams = new Map()
const markedCommands = new Map()

const KeyboardInteractiveAttempts = new Map()
export const connectionStatus = new Map()

// Set KeyboardInteractive authentication timeout (milliseconds)
const KeyboardInteractiveTimeout = 300000 // 5 minutes timeout
const MaxKeyboardInteractiveAttempts = 5 // Max KeyboardInteractive attempts

const EventEmitter = require('events')
const connectionEvents = new EventEmitter()

// Cache
export const keyboardInteractiveOpts = new Map<string, string[]>()

export const getReusableSshConnection = (host: string, port: number, username: string) => {
  const poolKey = getConnectionPoolKey(host, port, username)
  const reusableConn = sshConnectionPool.get(poolKey)
  if (!reusableConn || !reusableConn.hasMfaAuth) {
    return null
  }

  const client = reusableConn.conn as Client | undefined
  if (!client || (client as any)?._sock?.destroyed) {
    sshConnectionPool.delete(poolKey)
    return null
  }

  return {
    poolKey,
    conn: client
  }
}

export const registerReusableSshSession = (poolKey: string, sessionId: string) => {
  const reusableConn = sshConnectionPool.get(poolKey)
  if (reusableConn) {
    reusableConn.sessions.add(sessionId)
  }
}

export const releaseReusableSshSession = (poolKey: string, sessionId: string) => {
  const reusableConn = sshConnectionPool.get(poolKey)
  if (reusableConn) {
    reusableConn.sessions.delete(sessionId)
  }
}

export const handleRequestKeyboardInteractive = (event, id, prompts, finish) => {
  return new Promise((_resolve, reject) => {
    // Get current retry count
    const attemptCount = KeyboardInteractiveAttempts.get(id) || 0

    // Check if maximum retry attempts exceeded
    if (attemptCount >= MaxKeyboardInteractiveAttempts) {
      KeyboardInteractiveAttempts.delete(id)
      // Send final failure event
      event.sender.send('ssh:keyboard-interactive-result', {
        id,
        attempts: attemptCount,
        status: 'failed',
        final: true
      })
      reject(new Error('Maximum authentication attempts reached'))
      return
    }

    // Set retry count
    KeyboardInteractiveAttempts.set(id, attemptCount + 1)

    // Send MFA request to frontend
    event.sender.send('ssh:keyboard-interactive-request', {
      id,
      prompts: prompts.map((p) => p.prompt)
    })

    // Set timeout
    const timeoutId = setTimeout(() => {
      // Remove listener
      ipcMain.removeAllListeners(`ssh:keyboard-interactive-response:${id}`)
      ipcMain.removeAllListeners(`ssh:keyboard-interactive-cancel:${id}`)

      // Cancel authentication
      finish([])
      KeyboardInteractiveAttempts.delete(id)
      event.sender.send('ssh:keyboard-interactive-timeout', { id })
      reject(new Error('Authentication timed out, please try connecting again'))
    }, KeyboardInteractiveTimeout)

    // Listen for user response
    ipcMain.once(`ssh:keyboard-interactive-response:${id}`, (_evt, responses) => {
      clearTimeout(timeoutId) // Clear timeout timer
      finish(responses)

      // Listen for connection status changes to determine verification result
      const statusHandler = (status) => {
        if (status.isVerified) {
          // Verification successful
          keyboardInteractiveOpts.set(id, responses)
          KeyboardInteractiveAttempts.delete(id)
          event.sender.send('ssh:keyboard-interactive-result', {
            id,
            status: 'success'
          })
        } else {
          // Verification failed
          const currentAttempts = KeyboardInteractiveAttempts.get(id) || 0
          event.sender.send('ssh:keyboard-interactive-result', {
            id,
            attempts: currentAttempts,
            status: 'failed'
          })
          // SSH connection will automatically retrigger keyboard-interactive event for retry
        }
        connectionEvents.removeListener(`connection-status-changed:${id}`, statusHandler)
      }

      connectionEvents.once(`connection-status-changed:${id}`, statusHandler)
    })

    // Listen for user cancellation
    ipcMain.once(`ssh:keyboard-interactive-cancel:${id}`, () => {
      KeyboardInteractiveAttempts.delete(id)
      clearTimeout(timeoutId)
      finish([])
      reject(new Error('Authentication cancelled'))
    })
  })
}

export const attemptSecondaryConnection = async (event, connectionInfo, ident) => {
  const { id, host, port, username, password, privateKey, passphrase, needProxy, proxyConfig, asset_type } = connectionInfo

  // Check if this is a network switch connection
  const isSwitch = asset_type?.startsWith('person-switch-')
  const switchBrand = isSwitch ? (asset_type === 'person-switch-cisco' ? 'cisco' : 'huawei') : null

  // For switches, skip secondary connection logic and return minimal ready data
  if (isSwitch && switchBrand) {
    const readyResult = {
      isSwitch: true,
      switchBrand,
      hasSudo: false,
      commandList: []
    }
    event.sender.send(`ssh:connect:data:${id}`, readyResult)
    if (keyboardInteractiveOpts.has(id)) {
      keyboardInteractiveOpts.delete(id)
    }
    return
  }

  const conn = new Client()
  const algorithms = getAlgorithmsByAssetType(asset_type)
  const connectConfig: any = {
    host,
    port: port || 22,
    username,
    keepaliveInterval: 10000,
    readyTimeout: KeyboardInteractiveTimeout,
    ident: ident,
    algorithms
  }

  if (privateKey) {
    connectConfig.privateKey = privateKey
    if (passphrase) connectConfig.passphrase = passphrase
  } else if (password) {
    connectConfig.password = password
  }

  if (needProxy) {
    logger.debug('Using proxy for secondary connection', { event: 'ssh.proxy', connectionId: id })
    connectConfig.sock = await createProxySocket(proxyConfig, host, port)
  }

  // Send initialization command result
  const readyResult: {
    hasSudo?: boolean
    commandList?: string[]
  } = {}

  let execCount = 0
  const totalCounts = 2
  const hasOpt = keyboardInteractiveOpts.has(id)
  const sendReadyData = (stopCount) => {
    execCount++
    if (execCount === totalCounts || stopCount) {
      event.sender.send(`ssh:connect:data:${id}`, readyResult)
      if (hasOpt) {
        keyboardInteractiveOpts.delete(id)
      }
    }
  }

  if (hasOpt) {
    connectConfig.tryKeyboard = true
    conn.on('keyboard-interactive', (_name, _instructions, _instructionsLang, _prompts, finish) => {
      const cached = keyboardInteractiveOpts.get(id)
      finish(cached || [])
    })
  }

  const sftpAsync = (conn) => {
    return new Promise<void>((resolve) => {
      conn.sftp((err, sftp) => {
        if (err || !sftp) {
          logger.debug('SFTP check error', { event: 'ssh.sftp.error', connectionId: id, error: err?.message || 'SFTP object is empty' })
          connectionStatus.set(id, {
            sftpAvailable: false,
            sftpError: err?.message || 'SFTP object is empty'
          })
          sftpConnections.set(id, { isSuccess: false, error: `sftp init error: "${err?.message || 'SFTP object is empty'}"` })
          resolve()
        } else {
          logger.debug('Starting SFTP check', { event: 'ssh.sftp.start', connectionId: id })
          sftp.readdir('.', (readDirErr) => {
            if (readDirErr) {
              logger.debug('SFTP check failed', { event: 'ssh.sftp.failed', connectionId: id, error: readDirErr.message })
              connectionStatus.set(id, {
                sftpAvailable: false,
                sftpError: readDirErr.message
              })
              sftp.end()
            } else {
              logger.debug('SFTP check success', { event: 'ssh.sftp.success', connectionId: id })
              sftpConnections.set(id, { isSuccess: true, sftp: sftp })
              connectionStatus.set(id, { sftpAvailable: true })
            }
            resolve()
          })
        }
      })
    })
  }

  conn
    .on('ready', async () => {
      // Perform sftp check
      try {
        await sftpAsync(conn)
      } catch (e) {
        connectionStatus.set(id, {
          sftpAvailable: false,
          sftpError: 'SFTP connection failed'
        })
      }

      // Perform cmd check
      try {
        let stdout = ''
        let stderr = ''
        conn.exec(
          'sh -c \'if command -v bash >/dev/null 2>&1; then bash -lc "compgen -A builtin; compgen -A command"; bash -ic "compgen -A alias" 2>/dev/null; else IFS=:; for d in $PATH; do [ -d "$d" ] || continue; for f in "$d"/*; do [ -x "$f" ] && printf "%s\\n" "${f##*/}"; done; done; fi\' | sort -u',
          (err, stream) => {
            if (err) {
              readyResult.commandList = []
              sendReadyData(false)
            } else {
              stream
                .on('data', (data: Buffer) => {
                  stdout += data.toString('utf8')
                })
                .stderr.on('data', (data: Buffer) => {
                  stderr += data.toString('utf8')
                })
                .on('close', () => {
                  if (stderr) {
                    readyResult.commandList = []
                  } else {
                    readyResult.commandList = stdout.split('\n').filter(Boolean)
                  }
                  sendReadyData(false)
                })
            }
          }
        )
      } catch (e) {
        readyResult.commandList = []
        sendReadyData(false)
      }

      // Perform sudo check
      try {
        conn.exec('sudo -n true 2>/dev/null && echo true || echo false', (err, stream) => {
          if (err) {
            readyResult.hasSudo = false
            sendReadyData(false)
          } else {
            stream
              .on('data', (data: Buffer) => {
                const result = data.toString('utf8').trim()
                readyResult.hasSudo = result === 'true'
              })
              .stderr.on('data', () => {
                readyResult.hasSudo = false
              })
              .on('close', () => {
                sendReadyData(false)
              })
          }
        })
      } catch (e) {
        readyResult.hasSudo = false
        sendReadyData(false)
      }
    })
    .on('error', (err) => {
      sftpConnections.set(id, { isSuccess: false, error: `sftp connection error: "${err.message}"` })
      readyResult.hasSudo = false
      readyResult.commandList = []
      sendReadyData(true)
      connectionStatus.set(id, {
        sftpAvailable: false,
        sftpError: err.message
      })
    })
  sshConnections.set(id + '-second', conn) // Save connection object
  conn.connect(connectConfig)
}

function splitCommand(cmd: string): string[] {
  return cmd.match(/(?:[^\s"]+|"[^"]*")+/g)?.map((s) => s.replace(/^"(.*)"$/, '$1')) || []
}

export async function createProxyCommandSocket(commandStr: string, host: string, port: number): Promise<any> {
  const replaced = commandStr.replace(/%h/g, host).replace(/%p/g, String(port))

  // Use shell: true to handle cmd.exe /c command under Windows
  const isWindowsCmd = process.platform === 'win32' && replaced.trim().startsWith('cmd.exe /c')

  let proc
  if (isWindowsCmd) {
    proc = spawn(replaced, [], {
      stdio: ['pipe', 'pipe', 'inherit'],
      windowsHide: true,
      shell: true
    })
  } else if (replaced.trim().startsWith('sh -c ')) {
    let cmdString = replaced.trim().slice(6).trim()

    if ((cmdString.startsWith('"') && cmdString.endsWith('"')) || (cmdString.startsWith("'") && cmdString.endsWith("'"))) {
      cmdString = cmdString.slice(1, -1)
    }
    proc = spawn('sh', ['-c', cmdString], {
      stdio: ['pipe', 'pipe', 'inherit'],
      windowsHide: true
    })
  } else {
    // segmentation parameters
    const [cmd, ...args] = splitCommand(replaced)
    proc = spawn(cmd, args, {
      stdio: ['pipe', 'pipe', 'inherit'],
      windowsHide: true
    })
  }

  // Create bidirectional packaging flow
  const socketProxy = new Duplex({
    read() {
      /* No-op: Data is pushed externally from process stdout */
    },
    write(chunk, encoding, callback) {
      if (proc.stdin && proc.stdin.writable) {
        proc.stdin.write(chunk, encoding, callback)
      } else {
        callback(new Error('ProxyCommand stdin is not writable'))
      }
    }
  })

  // Bridge the stdout data of the child process to the wrapper stream
  proc.stdout.on('data', (chunk) => {
    if (!socketProxy.push(chunk)) {
      proc.stdout.pause()
    }
  })

  // backpressure handling
  socketProxy.on('drain', () => {
    if (proc.stdout.isPaused()) {
      proc.stdout.resume()
    }
  })

  const cleanup = () => {
    if (proc && !proc.killed) proc.kill()
    if (!socketProxy.destroyed) socketProxy.destroy()
  }

  proc.stdout.on('end', () => socketProxy.push(null))
  proc.on('error', (err) => socketProxy.emit('error', err))
  proc.on('exit', (code) => {
    if (code !== 0 && code !== null) {
      socketProxy.emit('error', new Error(`Exit code ${code}`))
    }
  })

  socketProxy.on('close', cleanup)
  socketProxy.on('finish', () => {
    if (proc.stdin && proc.stdin.writable) proc.stdin.end()
  })
  ;(socketProxy as any).writable = true
  ;(socketProxy as any).readable = true

  return socketProxy
}
const handleAttemptConnection = async (event, connectionInfo, resolve, reject, retryCount) => {
  const {
    id,
    host,
    port,
    username,
    password,
    privateKey,
    passphrase,
    agentForward,
    needProxy,
    proxyConfig,
    connIdentToken,
    asset_type,
    proxyCommand
  } = connectionInfo
  retryCount++

  connectionStatus.set(id, { isVerified: false }) // Update connection status
  const identToken = connIdentToken ? `_t=${connIdentToken}` : ''
  const ident = `${packageInfo.name}_${packageInfo.version}` + identToken

  // Check connection reuse pool: only attempt reuse when using keyboard-interactive authentication
  const poolKey = getConnectionPoolKey(host, port || 22, username)
  const reusableConn = sshConnectionPool.get(poolKey)

  if (reusableConn && reusableConn.hasMfaAuth) {
    logger.info('Detected reusable MFA connection', { event: 'ssh.reuse', connectionId: id, poolKey })

    // Use existing connection
    const conn = reusableConn.conn

    // Mark current session as connected
    sshConnections.set(id, conn)
    connectionStatus.set(id, { isVerified: true })
    reusableConn.sessions.add(id)

    // Trigger connection success event
    connectionEvents.emit(`connection-status-changed:${id}`, { isVerified: true })

    // Execute secondary connection (sudo check, SFTP, etc.)
    attemptSecondaryConnection(event, connectionInfo, ident)

    logger.info('Successfully reused MFA connection', { event: 'ssh.reuse.success', connectionId: id })
    resolve({ status: 'connected', message: 'Connection successful (reused)' })
    return
  }

  const conn = new Client()

  conn.on('ready', () => {
    sshConnections.set(id, conn) // Save connection object
    connectionStatus.set(id, { isVerified: true })
    connectionEvents.emit(`connection-status-changed:${id}`, { isVerified: true })

    // Check if keyboard-interactive authentication was used
    // Must check before attemptSecondaryConnection as it will clear keyboardInteractiveOpts
    const hasKeyboardInteractive = keyboardInteractiveOpts.has(id)

    // If keyboard-interactive authentication was used, immediately save to connection pool for future reuse
    if (hasKeyboardInteractive) {
      const poolKey = getConnectionPoolKey(host, port || 22, username)
      logger.info('Saving MFA authenticated connection to pool', { event: 'ssh.pool.save', poolKey })

      sshConnectionPool.set(poolKey, {
        conn: conn,
        sessions: new Set([id]),
        host: host,
        port: port || 22,
        username: username,
        hasMfaAuth: true
      })

      // Listen for connection close event to clean up connection pool
      conn.on('close', () => {
        logger.info('Pooled connection closed, cleaning up', { event: 'ssh.pool.cleanup', poolKey })
        sshConnectionPool.delete(poolKey)
      })

      conn.on('error', (err) => {
        logger.error('Pooled connection error, cleaning up', { event: 'ssh.pool.error', poolKey, error: err.message })
        sshConnectionPool.delete(poolKey)
      })
    }

    // Execute secondary connection (this will clear keyboardInteractiveOpts, so must be placed after the check)
    attemptSecondaryConnection(event, connectionInfo, ident)

    resolve({ status: 'connected', message: 'Connection successful' })
  })

  conn.on('error', (err) => {
    connectionStatus.set(id, { isVerified: false })

    connectionEvents.emit(`connection-status-changed:${id}`, { isVerified: false })
    if (err.level === 'client-authentication' && KeyboardInteractiveAttempts.has(id)) {
      logger.info('Authentication failed, retrying', { event: 'ssh.auth.retry', connectionId: id, retryCount })

      if (retryCount < MaxKeyboardInteractiveAttempts) {
        handleAttemptConnection(event, connectionInfo, resolve, reject, retryCount)
      } else {
        reject(new Error('Maximum retries reached, authentication failed'))
      }
    } else {
      logger.error('SSH connection error', { event: 'ssh.error', connectionId: id, error: err.message })
      reject(new Error(err.message))
    }
  })

  // Configure connection settings
  const algorithms = getAlgorithmsByAssetType(asset_type)
  const connectConfig: any = {
    host,
    port: port || 22,
    username,
    keepaliveInterval: 10000, // Keep connection alive
    tryKeyboard: true, // Enable keyboard interactive authentication
    readyTimeout: KeyboardInteractiveTimeout, // Connection timeout, 30 seconds
    algorithms
  }

  connectConfig.ident = ident

  if (agentForward) {
    const manager = SSHAgentManager.getInstance()
    // If using Agent authentication
    connectConfig.agent = manager.getAgent()
    connectConfig.agentForward = true
  }

  conn.on('keyboard-interactive', async (_name, _instructions, _instructionsLang, prompts, finish) => {
    try {
      // Wait for user response
      await handleRequestKeyboardInteractive(event, id, prompts, finish)
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err)
      logger.warn('SSH keyboard-interactive error', { event: 'ssh.keyboard-interactive.error', connectionId: id, error: errorMessage })

      // Only close connection when max retries exceeded, user cancelled, or timeout
      if (errorMessage.includes('Maximum authentication attempts') || errorMessage.includes('cancelled') || errorMessage.includes('timed out')) {
        conn.end() // Close connection
        reject(err)
      }
      // For other errors, let SSH connection handle naturally, may retrigger keyboard-interactive
    }
  })

  try {
    if (privateKey) {
      // Authenticate with private key
      connectConfig.privateKey = privateKey
      if (passphrase) {
        connectConfig.passphrase = passphrase
      }
    } else if (password) {
      // Authenticate with password
      connectConfig.password = password
    } else {
      reject(new Error('No valid authentication method provided'))
      return
    }

    try {
      if (proxyCommand) {
        connectConfig.sock = await createProxyCommandSocket(proxyCommand, host, port || 22)
        delete connectConfig.host
        delete connectConfig.port
      } else if (needProxy) {
        connectConfig.sock = await createProxySocket(proxyConfig, host, port)
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : String(err)
      return reject(new Error(`Failed to establish a transport layer tunnel: ${errorMessage}`))
    }
    conn.connect(connectConfig) // Attempt to connect
  } catch (err) {
    logger.error('Connection configuration error', { event: 'ssh.config.error', error: String(err) })
    reject(new Error(`Connection configuration error: ${err}`))
  }
}
export const getUniqueRemoteName = async (sftp: SFTPWrapper, remoteDir: string, originalName: string, isDir: boolean): Promise<string> => {
  const list = await new Promise<{ filename: string; longname: string; attrs: any }[]>((resolve, reject) => {
    sftp.readdir(remoteDir, (err, list) => (err ? reject(err) : resolve(list as any)))
  })
  let existing = new Set(list.map((f) => f.filename))

  if (isDir) {
    existing = new Set(list.filter((f) => f.attrs.isDirectory()).map((f) => f.filename))
  }

  let finalName = originalName
  const { name, ext } = path.parse(originalName)
  let count = 1

  while (existing.has(finalName)) {
    finalName = `${name}${ext}.${count}`
    count++
  }

  return finalName
}

export const getSftpConnection = (id: string): any => {
  const sftpConnectionInfo = sftpConnections.get(id)

  if (!sftpConnectionInfo) {
    logger.debug('SFTP connection not found', { event: 'ssh.sftp.notfound', connectionId: id })
    return null
  }

  if (!sftpConnectionInfo.isSuccess || !sftpConnectionInfo.sftp) {
    logger.debug('SFTP not available', { event: 'ssh.sftp.unavailable', connectionId: id, error: sftpConnectionInfo.error || 'Unknown error' })
    return null
  }

  return sftpConnectionInfo.sftp
}

export const cleanSftpConnection = (id) => {
  // Clean up SFTP
  if (sftpConnections.get(id)) {
    const sftp = getSftpConnection(id)
    sftp.end()
    sftpConnections.delete(id)
    if (sshConnections.get(id + '-second')) {
      const connSec = sshConnections.get(id + '-second')
      connSec.end()
      sshConnections.delete(id + '-second')
    }
  }
}

// Delete file
const handleDeleteFile = (_event, id, remotePath, resolve, reject) => {
  const sftp = getSftpConnection(id)
  if (!sftp) {
    return reject('Sftp Not connected')
  }

  if (!remotePath || remotePath.trim() === '' || remotePath.trim() === '*' || remotePath === '/') {
    return reject('Illegal path, cannot be deleted')
  }

  new Promise<void>((res, rej) => {
    sftp.unlink(remotePath, (err) => {
      if (err) return rej(err)
      res()
    })
  })
    .then(() => {
      resolve({
        status: 'success',
        message: 'File deleted successfully',
        deletedPath: remotePath
      })
    })
    .catch((err) => {
      const errorMessage = err instanceof Error ? err.message : String(err)
      reject(`Delete failed: ${errorMessage}`)
    })
}

// download file
export const activeTasks = new Map<string, { read: any; write: any; localPath?: string; cancel?: () => void }>()
async function handleStreamTransfer(event: any, id: string, srcPath: string, destPath: string, type: 'download' | 'upload', isInternalCall = false) {
  const sftp = getSftpConnection(id)
  let finalDestPath = destPath.replace(/\\/g, '/')

  if (type === 'upload' && !isInternalCall) {
    const fileName = path.basename(srcPath)
    // Calculate unique file names
    const uniqueName = await getUniqueRemoteName(sftp, finalDestPath, fileName, false)
    finalDestPath = path.posix.join(finalDestPath, uniqueName)
  }

  const remotePathForKey = type === 'upload' ? finalDestPath : srcPath
  const taskKey = type === 'download' ? `${id}:dl:${srcPath}:${finalDestPath}` : `${id}:up:${srcPath}:${finalDestPath}`

  if (activeTasks.has(taskKey)) {
    return { status: 'skipped', message: 'Task already in progress' }
  }

  return new Promise((resolve, reject) => {
    let isCancelled = false

    const getStats = type === 'download' ? (p: string, cb: any) => sftp.stat(p, cb) : (p: string, cb: any) => cb(null, fs.statSync(p))

    getStats(srcPath, (err: any, stats: any) => {
      if (err) return reject(err)

      const readStream = type === 'download' ? sftp.createReadStream(srcPath) : fs.createReadStream(srcPath)
      const writeStream = type === 'download' ? fs.createWriteStream(finalDestPath) : sftp.createWriteStream(finalDestPath)

      activeTasks.set(taskKey, {
        read: readStream,
        write: writeStream,
        localPath: type === 'download' ? finalDestPath : srcPath,
        cancel: () => {
          isCancelled = true
          readStream.destroy()
          writeStream.destroy()
        }
      })

      let transferred = 0
      let lastEmitTime = 0

      readStream.on('data', (chunk: Buffer) => {
        transferred += chunk.length
        const now = Date.now()
        if (now - lastEmitTime > 150 || transferred === stats.size) {
          event.sender.send('ssh:sftp:transfer-progress', {
            id,
            taskKey: taskKey,
            remotePath: remotePathForKey,
            bytes: transferred,
            total: stats.size,
            type
          })
          lastEmitTime = now
        }
      })

      readStream.pipe(writeStream)

      writeStream.on('close', () => {
        activeTasks.delete(taskKey)

        if (isCancelled) {
          resolve({ status: 'cancelled', message: 'Transfer was cancelled by user' })
        } else {
          resolve({ status: 'success', remotePath: finalDestPath })
        }
      })

      const handleError = (e: any) => {
        if (isCancelled) return

        readStream.destroy()
        writeStream.destroy()
        activeTasks.delete(taskKey)
        reject(e)
      }

      readStream.on('error', handleError)
      writeStream.on('error', handleError)
    })
  })
}

async function handleDirectoryTransfer(event: any, id: string, localDir: string, remoteDir: string) {
  const sftp = getSftpConnection(id)
  const originalDirName = path.basename(localDir)

  const finalDirName = await getUniqueRemoteName(sftp, remoteDir, originalDirName, true)
  const finalRemoteBaseDir = path.posix.join(remoteDir, finalDirName).replace(/\\/g, '/')

  const allFileTasks: { local: string; remote: string }[] = []
  const allDirs = new Set<string>()
  allDirs.add(finalRemoteBaseDir)

  const scan = (currentLocal: string, currentRemote: string) => {
    const files = fs.readdirSync(currentLocal)
    for (const file of files) {
      const lPath = path.join(currentLocal, file)
      const rPath = path.posix.join(currentRemote, file)
      const stat = fs.statSync(lPath)
      if (stat.isDirectory()) {
        allDirs.add(rPath)
        scan(lPath, rPath)
      } else {
        allFileTasks.push({ local: lPath, remote: rPath })
      }
    }
  }
  scan(localDir, finalRemoteBaseDir)

  // mkdir
  const sortedDirs = Array.from(allDirs).sort((a, b) => a.length - b.length)
  for (const dir of sortedDirs) {
    await new Promise<void>((res) => sftp.mkdir(dir, { mode: 0o755 }, () => res()))
  }

  const promises = allFileTasks.map((task) =>
    handleStreamTransfer(event, id, task.local, task.remote, 'upload', true).catch((err) => logger.error('Directory upload file error', { event: 'ssh.sftp.upload.error', remotePath: task.remote, error: err instanceof Error ? err.message : String(err) }))
  )

  await Promise.all(promises)
  return { status: 'success' }
}

export const registerSSHHandlers = () => {
  // Handle connection
  ipcMain.handle('ssh:connect', async (_event, connectionInfo) => {
    const { sshType } = connectionInfo

    if (sshType === 'jumpserver') {
      // Route to JumpServer connection
      try {
        const result = await handleJumpServerConnection(connectionInfo, _event)
        return result
      } catch (error: unknown) {
        return buildErrorResponse(error)
      }
    }

    const bastionResult = await connectBastionByType(sshType, connectionInfo, _event)
    if (bastionResult !== null) {
      return bastionResult
    }

    // Default to SSH connection when sshType is missing or explicitly 'ssh'
    const retryCount = 0
    return new Promise((resolve, reject) => {
      handleAttemptConnection(_event, connectionInfo, resolve, reject, retryCount)
    })
  })

  ipcMain.handle('ssh:sftp:conn:check', async (_event, { id }) => {
    if (connectionStatus.has(id)) {
      const status = connectionStatus.get(id)
      return status?.sftpAvailable === true
    }
    return false
  })

  ipcMain.handle('ssh:sftp:conn:list', async () => {
    return Array.from(sftpConnections.entries()).map(([key, sftpConn]) => ({
      id: key,
      isSuccess: sftpConn.isSuccess,
      error: sftpConn.error
    }))
  })

  ipcMain.handle('ssh:shell', async (event, { id, terminalType }) => {
    // Check if it's a JumpServer connection
    if (jumpserverConnections.has(id)) {
      // Use JumpServer shell handling
      const stream = jumpserverShellStreams.get(id)
      if (!stream) {
        return { status: 'error', message: 'JumpServer connection not found' }
      }

      // Clear old listeners
      stream.removeAllListeners('data')

      let buffer = ''
      let flushTimer: NodeJS.Timeout | null = null
      let rawChunks: Buffer[] = []
      let rawBytes = 0
      const flushBuffer = () => {
        if (!buffer && rawBytes === 0) return
        const chunk = buffer
        buffer = ''
        const raw = rawBytes ? Buffer.concat(rawChunks, rawBytes) : undefined

        rawChunks = []
        rawBytes = 0
        event.sender.send(`ssh:shell:data:${id}`, { data: chunk, raw, marker: '' })
        flushTimer = null
      }

      const scheduleFlush = () => {
        // Clear existing timer to prevent multiple timers
        if (flushTimer) {
          clearTimeout(flushTimer)
        }

        const delay = getDelayByBufferSize(buffer.length)

        if (delay === 0) {
          // Send immediately for small data (likely user input)
          flushBuffer()
        } else {
          // Schedule delayed flush for larger data
          flushTimer = setTimeout(flushBuffer, delay)
        }
      }

      stream.on('data', (data) => {
        const dataStr = data.toString('utf8')
        const lastCommand = jumpserverLastCommand.get(id)
        const exitCommands = ['exit', 'logout', '\x04']

        // JumpServer menu exit detection
        if (dataStr.includes('[Host]>') && lastCommand && exitCommands.includes(lastCommand)) {
          jumpserverLastCommand.delete(id)
          stream.write('q\r', (err) => {
            if (err) logger.error('Failed to send quit command to JumpServer', { event: 'jumpserver.quit.error', connectionId: id, error: err.message })
            else logger.debug('Sent quit command to JumpServer session', { event: 'jumpserver.quit', connectionId: id })
            stream.end()
            const connData = jumpserverConnections.get(id)
            connData?.conn?.end()
          })
          return
        }

        const markedCmd = jumpserverMarkedCommands.get(id)
        if (markedCmd !== undefined) {
          if (markedCmd.marker === 'Chaterm:command') {
            event.sender.send(`ssh:shell:data:${id}`, {
              data: dataStr,
              raw: data,
              marker: markedCmd.marker
            })
            return
          }
          markedCmd.output += dataStr
          markedCmd.rawChunks.push(data)
          markedCmd.rawBytes += data.length
          markedCmd.lastActivity = Date.now()
          if (markedCmd.idleTimer) clearTimeout(markedCmd.idleTimer)
          markedCmd.idleTimer = setTimeout(() => {
            if (markedCmd && !markedCmd.completed) {
              markedCmd.completed = true
              const markedRaw = markedCmd.rawBytes ? Buffer.concat(markedCmd.rawChunks, markedCmd.rawBytes) : undefined
              event.sender.send(`ssh:shell:data:${id}`, {
                data: markedCmd.output,
                raw: markedRaw,
                marker: markedCmd.marker
              })
              jumpserverMarkedCommands.delete(id)
            }
          }, 200)
        } else {
          // Only add to shared buffer for non-marked data
          rawChunks.push(data)
          rawBytes += data.length
          buffer += dataStr
          scheduleFlush()
        }
      })

      stream.stderr.on('data', (data) => {
        event.sender.send(`ssh:shell:stderr:${id}`, data.toString('utf8'))
      })

      stream.on('close', () => {
        flushBuffer()
        logger.debug('JumpServer shell stream closed', { event: 'jumpserver.stream.close', connectionId: id })
        event.sender.send(`ssh:shell:close:${id}`)
        jumpserverShellStreams.delete(id)
      })

      return { status: 'success', message: 'JumpServer Shell ready' }
    }

    const bastionShellResult = await shellBastionSession(event, id, terminalType)
    if (bastionShellResult !== null) {
      return bastionShellResult
    }

    // Default SSH shell handling
    const conn = sshConnections.get(id)
    if (!conn) {
      return { status: 'error', message: 'Not connected to the server' }
    }

    const termType = terminalType || 'vt100'
    const delayMs = 300
    const fallbackExecs = ['bash', 'sh']

    const isConnected = () => conn && conn['_sock'] && !conn['_sock'].destroyed

    const handleStream = (stream, method: 'shell' | 'exec') => {
      shellStreams.set(id, stream)

      let buffer = ''
      let flushTimer: NodeJS.Timeout | null = null
      let rawChunks: Buffer[] = []
      let rawBytes = 0
      const flushBuffer = () => {
        if (!buffer && rawBytes === 0) return

        const chunk = buffer
        buffer = ''

        const raw = rawBytes ? Buffer.concat(rawChunks, rawBytes) : undefined

        rawChunks = []
        rawBytes = 0
        event.sender.send(`ssh:shell:data:${id}`, { data: chunk, raw, marker: '' })
        flushTimer = null
      }

      const scheduleFlush = () => {
        // Clear existing timer to prevent multiple timers
        if (flushTimer) {
          clearTimeout(flushTimer)
        }

        const delay = getDelayByBufferSize(buffer.length)

        if (delay === 0) {
          // Send immediately for small data (likely user input)
          flushBuffer()
        } else {
          // Schedule delayed flush for larger data
          flushTimer = setTimeout(flushBuffer, delay)
        }
      }

      stream.on('data', (data) => {
        const markedCmd = markedCommands.get(id)
        const chunk = data.toString('utf8')

        if (markedCmd !== undefined) {
          markedCmd.output += chunk
          markedCmd.rawChunks.push(data)
          markedCmd.rawBytes += data.length
          markedCmd.lastActivity = Date.now()
          if (markedCmd.idleTimer) clearTimeout(markedCmd.idleTimer)
          markedCmd.idleTimer = setTimeout(() => {
            if (markedCmd && !markedCmd.completed) {
              markedCmd.completed = true
              const markedRaw = markedCmd.rawBytes ? Buffer.concat(markedCmd.rawChunks, markedCmd.rawBytes) : undefined
              event.sender.send(`ssh:shell:data:${id}`, {
                data: markedCmd.output,
                raw: markedRaw,
                marker: markedCmd.marker
              })
              markedCommands.delete(id)
            }
          }, 200)
        } else {
          // Only add to shared buffer for non-marked data
          rawChunks.push(data)
          rawBytes += data.length
          buffer += chunk
          scheduleFlush()
        }
      })

      stream.stderr?.on('data', (data) => {
        event.sender.send(`ssh:shell:stderr:${id}`, data.toString('utf8'))
      })

      stream.on('close', () => {
        flushBuffer()
        logger.debug('Shell stream closed', { event: 'ssh.stream.close', connectionId: id, method })
        event.sender.send(`ssh:shell:close:${id}`)
        shellStreams.delete(id)
      })
    }

    const tryExecFallback = (execList: string[], resolve, reject) => {
      const [cmd, ...rest] = execList
      if (!cmd) {
        return reject(new Error('shell and exec run failed'))
      }

      conn.exec(cmd, { pty: true }, (execErr, execStream) => {
        if (execErr) {
          logger.warn('Shell exec fallback failed', { event: 'ssh.exec.failed', connectionId: id, cmd, error: execErr.message })
          return tryExecFallback(rest, resolve, reject)
        }

        logger.info('Terminal started via exec fallback', { event: 'ssh.exec.success', connectionId: id, cmd })
        handleStream(execStream, 'exec')
        resolve({ status: 'success', message: `The terminal has been started（exec:${cmd}）` })
      })
    }

    return new Promise((resolve, reject) => {
      if (!isConnected()) return reject(new Error('Connection disconnected, unable to start terminal'))

      setTimeout(() => {
        if (!isConnected()) return reject(new Error('The connection has been disconnected after a delay'))

        conn.shell({ term: termType }, (err, stream) => {
          if (err) {
            logger.warn('Shell start error, falling back to exec', { event: 'ssh.shell.error', connectionId: id, error: err.message })
            return tryExecFallback(fallbackExecs, resolve, reject)
          }

          logger.info('Shell started successfully', { event: 'ssh.shell.success', connectionId: id })
          handleStream(stream, 'shell')
          resolve({ status: 'success', message: 'Shell has started' })
        })
      }, delayMs)
    })
  })

  // Resize handling
  ipcMain.handle('ssh:shell:resize', async (_event, { id, cols, rows }) => {
    // Check if it's a JumpServer connection
    if (jumpserverConnections.has(id)) {
      const stream = jumpserverShellStreams.get(id)
      if (!stream) {
        return { status: 'error', message: 'JumpServer Shell not found' }
      }

      try {
        stream.setWindow(rows, cols, 0, 0)
        return { status: 'success', message: `JumpServer window size set to ${cols}x${rows}` }
      } catch (error: unknown) {
        return { status: 'error', message: error instanceof Error ? error.message : String(error) }
      }
    }

    const bastionResizeResult = await resizeBastionSession(id, cols, rows)
    if (bastionResizeResult !== null) {
      return bastionResizeResult
    }

    // Default SSH handling
    const stream = shellStreams.get(id)
    if (!stream) {
      return { status: 'error', message: 'Shell not found' }
    }

    try {
      // Set SSH shell window size
      stream.setWindow(rows, cols, 0, 0)
      return { status: 'success', message: `Window size set to  ${cols}x${rows}` }
    } catch (error: unknown) {
      return { status: 'error', message: error instanceof Error ? error.message : String(error) }
    }
  })

  ipcMain.on('ssh:shell:write', (_event, { id, data, marker, lineCommand, isBinary }) => {
    // Check if it's a JumpServer connection
    if (jumpserverConnections.has(id)) {
      const stream = jumpserverShellStreams.get(id)
      if (stream) {
        if (isBinary) {
          const buf = Buffer.from(data, 'binary')
          stream.write(buf)
        } else {
          // Use lineCommand for command detection, if not, fallback to data-trim()
          const command = lineCommand || data.trim()
          if (['exit', 'logout', '\x04'].includes(command)) {
            jumpserverLastCommand.set(id, command)
          } else {
            jumpserverLastCommand.delete(id)
          }
          if (jumpserverMarkedCommands.has(id)) {
            jumpserverMarkedCommands.delete(id)
          }
          if (marker) {
            jumpserverMarkedCommands.set(id, {
              marker,
              output: '',
              rawChunks: [] as Uint8Array[],
              rawBytes: 0,
              raw: [] as Uint8Array[],
              completed: false,
              lastActivity: Date.now(),
              idleTimer: null
            })
          }

          stream.write(data)
        }
      } else {
        logger.warn('Attempting to write to non-existent JumpServer stream', { event: 'jumpserver.write.notfound', connectionId: id })
      }
      return
    }

    if (writeBastionSession(id, data, marker, lineCommand, isBinary)) {
      return
    }

    // Default SSH handling
    const stream = shellStreams.get(id)
    if (stream) {
      // For default SSH connections, don't detect exit commands, let terminal handle exit naturally
      if (markedCommands.has(id)) {
        markedCommands.delete(id)
      }
      if (marker) {
        markedCommands.set(id, {
          marker,
          output: '',
          rawChunks: [] as Uint8Array[],
          rawBytes: 0,
          raw: [] as Uint8Array[],
          completed: false,
          lastActivity: Date.now(),
          idleTimer: null
        })
      }

      if (isBinary) {
        const buf = Buffer.from(data, 'binary')
        stream.write(buf)
      } else {
        stream.write(data)
      }
    } else {
      logger.warn('Attempting to write to non-existent stream', { event: 'ssh.write.notfound', connectionId: id })
    }
  })

  /**
   * Execute command on JumpServer asset (simulate exec via shell stream)
   * @param id - Connection ID
   * @param cmd - Command to execute
   * @returns Execution result (compatible with standard exec format)
   */
  async function executeCommandOnJumpServerAsset(
    id: string,
    cmd: string
  ): Promise<{
    success: boolean
    stdout?: string
    stderr?: string
    exitCode?: number
    exitSignal?: string
    error?: string
  }> {
    // Get or create dedicated exec stream (not user interaction stream)
    let execStream: any
    try {
      execStream = await createJumpServerExecStream(id)
    } catch (error) {
      return {
        success: false,
        error: `Failed to create exec stream: ${error instanceof Error ? error.message : String(error)}`,
        stdout: '',
        stderr: '',
        exitCode: undefined,
        exitSignal: undefined
      }
    }

    if (!execStream) {
      return {
        success: false,
        error: 'JumpServer exec stream not available',
        stdout: '',
        stderr: '',
        exitCode: undefined,
        exitSignal: undefined
      }
    }

    return new Promise((resolve) => {
      const timestamp = Date.now()
      const marker = `__CHATERM_EXEC_END_${timestamp}__`
      const exitCodeMarker = `__CHATERM_EXIT_CODE_${timestamp}__`
      let outputBuffer = ''
      let timeoutHandle: NodeJS.Timeout

      // Output listener
      const dataHandler = (data: Buffer) => {
        outputBuffer += data.toString('utf8')

        // End marker detected
        if (outputBuffer.includes(marker)) {
          cleanup()

          try {
            // Extract output content (remove command echo and markers)
            const lines = outputBuffer.split('\n')

            // Find command line position (command echo)
            const commandIndex = lines.findIndex((line) => line.trim().includes(cmd.trim()))

            // Find end marker position
            const markerIndex = lines.findIndex((line) => line.includes(marker))

            // Extract command output (between command line and marker)
            const outputLines = lines.slice(commandIndex + 1, markerIndex)
            const stdout = outputLines.join('\n').trim()

            // Extract exit code (from content after exitCodeMarker)
            const exitCodePattern = new RegExp(`${exitCodeMarker}(\\d+)`)
            const exitCodeMatch = outputBuffer.match(exitCodePattern)
            const exitCode = exitCodeMatch ? parseInt(exitCodeMatch[1], 10) : 0

            resolve({
              success: exitCode === 0,
              stdout,
              stderr: '',
              exitCode,
              exitSignal: undefined
            })
          } catch (parseError) {
            // Return raw output on parse failure
            resolve({
              success: false,
              error: `Failed to parse command output: ${parseError}`,
              stdout: outputBuffer,
              stderr: '',
              exitCode: undefined,
              exitSignal: undefined
            })
          }
        }
      }

      // Cleanup function
      const cleanup = () => {
        execStream.removeListener('data', dataHandler)
        clearTimeout(timeoutHandle)
      }

      // Timeout protection (30 seconds)
      timeoutHandle = setTimeout(() => {
        cleanup()
        resolve({
          success: false,
          error: 'Command execution timeout (30s)',
          stdout: outputBuffer,
          stderr: '',
          exitCode: undefined,
          exitSignal: undefined
        })
      }, 30000)

      // Register listener
      execStream.on('data', dataHandler)

      // Send command (capture exit code)
      // Use bash trick: command; echo marker; echo exitcode_marker$?
      const fullCommand = `${cmd}; echo "${marker}"; echo "${exitCodeMarker}$?"\r`
      execStream.write(fullCommand)
    })
  }

  ipcMain.handle('ssh:conn:exec', async (_event, { id, cmd }) => {
    // Detect if it's a JumpServer connection, handle with priority
    if (jumpserverShellStreams.has(id)) {
      return executeCommandOnJumpServerAsset(id, cmd)
    }

    // Standard SSH connection handling
    const conn = sshConnections.get(id)
    if (!conn) {
      return {
        success: false,
        error: `No SSH connection for id=${id}`,
        stdout: '',
        stderr: '',
        exitCode: undefined,
        exitSignal: undefined
      }
    }

    return new Promise((resolve) => {
      conn.exec(cmd, (err, stream) => {
        if (err) {
          return resolve({
            success: false,
            error: err.message,
            stdout: '',
            stderr: '',
            exitCode: undefined,
            exitSignal: undefined
          })
        }

        const stdoutChunks: Buffer[] = []
        const stderrChunks: Buffer[] = []
        let exitCode = undefined
        let exitSignal = undefined

        stream.on('data', (chunk) => {
          stdoutChunks.push(chunk)
        })

        stream.stderr.on('data', (chunk) => {
          stderrChunks.push(chunk)
        })

        stream.on('exit', (code, signal) => {
          exitCode = code ?? undefined
          exitSignal = signal ?? undefined
        })

        stream.on('close', (code, signal) => {
          const finalCode = exitCode !== undefined ? exitCode : code
          const finalSignal = exitSignal !== undefined ? exitSignal : signal

          const stdout = Buffer.concat(stdoutChunks).toString('utf8')
          const stderr = Buffer.concat(stderrChunks).toString('utf8')

          resolve({
            success: true,
            stdout,
            stderr,
            exitCode: finalCode ?? undefined,
            exitSignal: finalSignal ?? undefined
          })
        })

        // Handle stream errors
        stream.on('error', (streamErr) => {
          // Optimization: use same concatenation method on error
          const stdout = Buffer.concat(stdoutChunks).toString('utf8')
          const stderr = Buffer.concat(stderrChunks).toString('utf8')

          resolve({
            success: false,
            error: streamErr.message,
            stdout,
            stderr,
            exitCode: undefined,
            exitSignal: undefined
          })
        })
      })
    })
  })

  ipcMain.handle('ssh:sftp:list', async (_e, { path, id }) => {
    return new Promise<unknown[]>((resolve) => {
      const sftp = getSftpConnection(id)
      if (!sftp) return resolve([''])

      sftp!.readdir(path, (err, list) => {
        if (err) {
          const errorCode = (err as { code?: number }).code
          switch (errorCode) {
            case 2: // SSH_FX_NO_SUCH_FILE
              return resolve([`cannot open directory '${path}': No such file or directory`])
            case 3: // SSH_FX_PERMISSION_DENIED
              return resolve([`cannot open directory '${path}': Permission denied`])
            case 4: // SSH_FX_FAILURE
              return resolve([`cannot open directory '${path}': Operation failed`])
            case 5: // SSH_FX_BAD_MESSAGE
              return resolve([`cannot open directory '${path}': Bad message format`])
            case 6: // SSH_FX_NO_CONNECTION
              return resolve([`cannot open directory '${path}': No connection`])
            case 7: // SSH_FX_CONNECTION_LOST
              return resolve([`cannot open directory '${path}': Connection lost`])
            case 8: // SSH_FX_OP_UNSUPPORTED
              return resolve([`cannot open directory '${path}': Operation not supported`])
            default:
              // Unknown error code
              const message = (err as Error).message || `Unknown error (code: ${errorCode})`
              return resolve([`cannot open directory '${path}': ${message}`])
          }
        }
        const files = list.map((item) => {
          const name = item.filename
          const attrs = item.attrs
          const prefix = path === '/' ? '/' : path + '/'
          return {
            name: name,
            path: prefix + name,
            isDir: attrs.isDirectory(),
            isLink: attrs.isSymbolicLink(),
            mode: '0' + (attrs.mode & 0o777).toString(8),
            modTime: new Date(attrs.mtime * 1000).toISOString().replace('T', ' ').slice(0, 19),
            size: attrs.size
          }
        })
        resolve(files)
      })
    })
  })

  ipcMain.handle('ssh:disconnect', async (_event, { id }) => {
    // Check if it's a JumpServer connection
    if (jumpserverConnections.has(id)) {
      const stream = jumpserverShellStreams.get(id)
      if (stream) {
        stream.end()
        jumpserverShellStreams.delete(id)
      }

      // Clean up exec stream
      const execStream = jumpserverExecStreams.get(id)
      if (execStream) {
        logger.debug('Cleaning up JumpServer exec stream', { event: 'jumpserver.exec.cleanup', connectionId: id })
        execStream.end()
        jumpserverExecStreams.delete(id)
      }

      const connData = jumpserverConnections.get(id)
      if (connData) {
        const connToClose = connData.conn

        // Check if other sessions are using the same connection
        let isConnStillInUse = false
        for (const [otherId, otherData] of jumpserverConnections.entries()) {
          if (otherId !== id && otherData.conn === connToClose) {
            isConnStillInUse = true
            break
          }
        }

        // Only close underlying connection when no other sessions are using it
        if (!isConnStillInUse) {
          logger.info('All JumpServer sessions closed, releasing underlying connection', { event: 'jumpserver.disconnect', connectionId: id })
          connToClose.end()
        } else {
          logger.debug('JumpServer session disconnected, underlying connection still in use', { event: 'jumpserver.disconnect.partial', connectionId: id })
        }
        cleanSftpConnection(id)
        jumpserverConnections.delete(id)
        jumpserverConnectionStatus.delete(id)
        return { status: 'success', message: 'JumpServer connection disconnected' }
      }

      return { status: 'warning', message: 'No active JumpServer connection' }
    }

    const bastionDisconnectResult = await disconnectBastionSession(id)
    if (bastionDisconnectResult !== null) {
      return bastionDisconnectResult
    }

    // Default SSH handling
    const stream = shellStreams.get(id)
    if (stream) {
      stream.end()
      shellStreams.delete(id)
    }

    const conn = sshConnections.get(id)
    if (conn) {
      // Check if this connection is in the reuse pool
      let poolKey: string | null = null
      let reusableConn: ReusableConnection | null = null

      // Iterate through connection pool to find matching connection
      sshConnectionPool.forEach((value, key) => {
        if (value.conn === conn) {
          poolKey = key
          reusableConn = value
        }
      })

      if (poolKey && reusableConn) {
        // Remove current session from session set
        ;(reusableConn as ReusableConnection).sessions.delete(id)

        // If no other sessions are using this connection, close connection and clean up pool
        if ((reusableConn as ReusableConnection).sessions.size === 0) {
          logger.info('All SSH pool sessions closed, releasing connection', { event: 'ssh.pool.release', poolKey })
          conn.end()
          sshConnectionPool.delete(poolKey)
        }
      } else {
        // Regular connection not in reuse pool, close directly
        conn.end()
      }
      cleanSftpConnection(id)
      sshConnections.delete(id)
      sftpConnections.delete(id)
      return { status: 'success', message: 'Disconnected' }
    }
    return { status: 'warning', message: 'No active connection' }
  })

  ipcMain.handle('ssh:recordTerminalState', async (_event, params) => {
    const { id, state } = params

    const connection = sshConnections.get(id)
    if (connection) {
      connection.terminalState = state
    }
    return { success: true }
  })

  ipcMain.handle('ssh:recordCommand', async (_event, params) => {
    const { id, command, timestamp } = params

    // Record command
    const connection = sshConnections.get(id)
    if (connection) {
      if (!connection.commandHistory) {
        connection.commandHistory = []
      }
      connection.commandHistory.push({ command, timestamp })
    }
    return { success: true }
  })

  //sftp
  ipcMain.handle('ssh:sftp:upload-file', (event, args) => handleStreamTransfer(event, args.id, args.localPath, args.remotePath, 'upload'))

  ipcMain.handle('ssh:sftp:upload-directory', (event, args) => handleDirectoryTransfer(event, args.id, args.localPath, args.remotePath))

  ipcMain.handle('ssh:sftp:download-file', (event, args) => handleStreamTransfer(event, args.id, args.remotePath, args.localPath, 'download'))

  ipcMain.handle('ssh:sftp:delete-file', (event, { id, remotePath }) => {
    return new Promise((resolve, reject) => {
      handleDeleteFile(event, id, remotePath, resolve, reject)
    })
  })

  ipcMain.handle('ssh:sftp:rename-move', async (_e, { id, oldPath, newPath }) => {
    const sftp = getSftpConnection(id)
    if (!sftp) return { status: 'error', message: 'Sftp Not connected' }

    try {
      if (oldPath === newPath) {
        return { status: 'success' }
      }
      await new Promise<void>((res, rej) => {
        sftp.rename(oldPath, newPath, (err) => (err ? rej(err) : res()))
      })
      return { status: 'success' }
    } catch (err) {
      return { status: 'error', message: (err as Error).message }
    }
  })

  ipcMain.handle('ssh:sftp:chmod', async (_e, { id, remotePath, mode, recursive }) => {
    const sftp = getSftpConnection(id)
    if (!sftp) return { status: 'error', message: 'Sftp Not connected' }

    try {
      const parsedMode = parseInt(String(mode), 8)
      logger.debug('SFTP chmod operation', { event: 'ssh.sftp.chmod', remotePath, mode: parsedMode, recursive })

      if (recursive) {
        const chmodRecursive = async (path: string): Promise<void> => {
          // Modify the permissions of the current path first
          await new Promise<void>((res, rej) => {
            sftp.chmod(path, parsedMode, (err) => (err ? rej(err) : res()))
          })

          // Retrieve directory contents
          const items = await new Promise<any[]>((res, rej) => {
            sftp.readdir(path, (err, list) => (err ? rej(err) : res(list || [])))
          })

          // Recursive processing of subdirectories and files
          for (const item of items) {
            if (item.filename === '.' || item.filename === '..') continue

            const itemPath = `${path}/${item.filename}`

            await new Promise<void>((res, rej) => {
              sftp.chmod(itemPath, parsedMode, (err) => (err ? rej(err) : res()))
            })

            if (item.attrs && item.attrs.isDirectory && item.attrs.isDirectory()) {
              await chmodRecursive(itemPath)
            }
          }
        }

        await chmodRecursive(remotePath)
      } else {
        await new Promise<void>((res, rej) => {
          sftp.chmod(remotePath, parsedMode, (err) => (err ? rej(err) : res()))
        })
      }

      return { status: 'success' }
    } catch (err) {
      return { status: 'error', message: (err as Error).message }
    }
  })

  ipcMain.handle('ssh:sftp:cancel-task', (_event, { taskKey }) => {
    const task = activeTasks.get(taskKey)

    if (task) {
      if (task.cancel) {
        task.cancel()
      } else {
        task.read.destroy()
        task.write.destroy()
      }
      activeTasks.delete(taskKey)
      return { status: 'aborted' }
    }
    return { status: 'not_found' }
  })

  // Select File
  ipcMain.handle('dialog:open-file', async (event) => {
    const result = await dialog.showOpenDialog(BrowserWindow.fromWebContents(event.sender)!, {
      title: 'Select File',
      properties: ['openFile']
    })
    return result.canceled ? null : result.filePaths[0]
  })

  // Select Directory
  ipcMain.handle('dialog:open-directory', async (event) => {
    const result = await dialog.showOpenDialog(BrowserWindow.fromWebContents(event.sender)!, {
      title: 'Select Directory',
      properties: ['openDirectory']
    })
    return result.canceled ? null : result.filePaths[0]
  })

  ipcMain.handle('dialog:save-file', async (event, { fileName }) => {
    const result = await dialog.showSaveDialog(BrowserWindow.fromWebContents(event.sender)!, {
      title: 'Save the file to...',
      defaultPath: fileName,
      buttonLabel: 'Save',
      filters: [{ name: 'All files', extensions: ['*'] }]
    })
    return result.canceled ? null : result.filePath
  })

  ipcMain.handle('ssh:agent:enable-and-configure', async (_event: any, { enabled }: { enabled: boolean }) => {
    const manager = SSHAgentManager.getInstance()

    try {
      await manager.enableAgent(enabled)
      logger.info('SSH Agent enabled', { event: 'ssh.agent.enabled' })
      return { success: true }
    } catch (error: any) {
      logger.error('SSH Agent enable failed', { event: 'ssh.agent.error', error: error?.message })
      return { success: false }
    }
  })

  ipcMain.handle('ssh:agent:add-key', async (_e, { keyData, passphrase, comment }) => {
    try {
      const manager = SSHAgentManager.getInstance()
      const keyId = await manager.addKey(keyData, passphrase, comment)
      return { success: true, keyId }
    } catch (error: any) {
      logger.error('SSH Agent add-key failed', { event: 'ssh.agent.addkey.error', error: error?.message })
      return { success: false, error: error.message }
    }
  })
  ipcMain.handle('ssh:agent:remove-key', async (_e, { keyId }) => {
    try {
      const manager = SSHAgentManager.getInstance()
      const removeStatus = manager.removeKey(keyId)
      return { success: removeStatus }
    } catch (error: any) {
      logger.error('SSH Agent add-key failed', { event: 'ssh.agent.addkey.error', error: error?.message })
      return { success: false, error: error.message }
    }
  })
  ipcMain.handle('ssh:agent:list-key', async (_e) => {
    try {
      const manager = SSHAgentManager.getInstance()
      const keyIdMapList = manager.listKeys()
      return { success: true, keys: keyIdMapList }
    } catch (error: any) {
      logger.error('SSH Agent add-key failed', { event: 'ssh.agent.addkey.error', error: error?.message })
      return { success: false, error: error.message }
    }
  })
  ipcMain.handle('ssh:get-system-info', async (_event, { id }) => {
    try {
      const systemInfo = await getSystemInfo(id)
      return { success: true, data: systemInfo }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to get system info'
      }
    }
  })

  // zmodem
  ipcMain.handle('zmodem:pickUploadFiles', async (evt) => {
    const win = require('electron').BrowserWindow.fromWebContents(evt.sender)
    const { canceled, filePaths } = await dialog.showOpenDialog(win, {
      properties: ['openFile', 'multiSelections']
    })
    if (canceled) return []

    return filePaths.map((p) => ({
      name: path.basename(p),
      lastModified: fs.statSync(p).mtimeMs,
      data: new Uint8Array(fs.readFileSync(p))
    }))
  })

  ipcMain.handle('zmodem:pickSavePath', async (evt, defaultName) => {
    const win = require('electron').BrowserWindow.fromWebContents(evt.sender)
    const { canceled, filePath } = await dialog.showSaveDialog(win, {
      defaultPath: defaultName
    })
    return canceled ? null : filePath
  })

  const activeStreams = new Map()

  ipcMain.handle('zmodem:openStream', (_event, savePath) => {
    try {
      const stream = fs.createWriteStream(savePath)
      const streamId = Math.random().toString(36).slice(2)
      activeStreams.set(streamId, stream)
      return streamId
    } catch (err) {
      logger.error('Failed to open zmodem stream', { event: 'ssh.zmodem.error', error: err instanceof Error ? err.message : String(err) })
      return null
    }
  })

  ipcMain.handle('zmodem:writeChunk', (_event, streamId, chunk) => {
    const stream = activeStreams.get(streamId)
    if (stream) {
      stream.write(Buffer.from(chunk))
    }
  })

  ipcMain.handle('zmodem:closeStream', (_event, streamId) => {
    const stream = activeStreams.get(streamId)
    if (stream) {
      stream.end()
      activeStreams.delete(streamId)
    }
  })
}

const getSystemInfo = async (id: string): Promise<CommandGenerationContext> => {
  let conn = sshConnections.get(id)
  if (!conn) {
    const connData = jumpserverConnections.get(id)
    conn = connData?.conn
  }
  if (!conn) {
    throw new Error('No active SSH connection found')
  }

  const systemInfoScript = `uname -a | sed 's/^/OS_VERSION:/' && echo "DEFAULT_SHELL:$SHELL" && echo "HOME_DIR:$HOME" && hostname | sed 's/^/HOSTNAME:/' && whoami | sed 's/^/USERNAME:/' && (sudo -n true 2>/dev/null && echo "SUDO_CHECK:has sudo permission" || echo "SUDO_CHECK:no sudo permission")`

  const inferPlatformFromOsVersion = (osVersion: string): string => {
    const v = (osVersion || '').toLowerCase()
    if (v.includes('darwin')) return 'darwin'
    if (v.includes('linux')) return 'linux'
    if (v.includes('mingw') || v.includes('msys') || v.includes('cygwin')) return 'win32'
    return 'unknown'
  }

  return new Promise((resolve, reject) => {
    conn.exec(systemInfoScript, (err, stream) => {
      if (err) {
        return reject(err)
      }

      let stdout = ''
      let stderr = ''

      stream.on('data', (data: Buffer) => {
        stdout += data.toString('utf8')
      })

      stream.stderr.on('data', (data: Buffer) => {
        stderr += data.toString('utf8')
      })

      stream.on('close', () => {
        if (stderr) {
          return reject(new Error(stderr))
        }

        const lines = stdout.trim().split('\n')
        const result: CommandGenerationContext = {
          platform: 'unknown',
          shell: 'bash',
          osVersion: '',
          hostname: '',
          username: '',
          homeDir: '',
          sudoPermission: false
        }

        lines.forEach((line) => {
          if (line.startsWith('OS_VERSION:')) {
            result.osVersion = line.replace('OS_VERSION:', '')
          } else if (line.startsWith('DEFAULT_SHELL:')) {
            result.shell = line.replace('DEFAULT_SHELL:', '')
          } else if (line.startsWith('HOME_DIR:')) {
            result.homeDir = line.replace('HOME_DIR:', '')
          } else if (line.startsWith('HOSTNAME:')) {
            result.hostname = line.replace('HOSTNAME:', '')
          } else if (line.startsWith('USERNAME:')) {
            result.username = line.replace('USERNAME:', '')
          } else if (line.startsWith('SUDO_CHECK:')) {
            result.sudoPermission = line.includes('has sudo permission')
          }
        })

        result.platform = inferPlatformFromOsVersion(result.osVersion || '')
        if (!result.shell) {
          result.shell = 'bash'
        }

        resolve(result)
      })
    })
  })
}
